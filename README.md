## 设计模式
[设计模式教程URL](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
#### 起因：2018-05-22 看JDBC 36节，被代理模式搞得一脸懵逼后，怒开新坑
### 设计模式分四类：
1. 创建型模式（Creational Patterns）-->对象怎么来
2. 结构型模式（Structural Patterns）-->对象和谁有关
3. 行为型模式（Behavioral Patterns）-->对象与对象在干嘛
4. J2EE模式 （J2EE Patterns）-->对象合起来要干嘛
 
### 设计模式的六大原则
1. 开闭原则（Open Close Principle）：实现热插拔，提高扩展性
2. 里氏代换原则（Liskov Substitution Principle）：实现抽象的规范，实现子父类互相替换
3. 依赖倒转原则（Dependence Inversion Principle）：针对接口编程，实现开闭原则的基础
4. 接口隔离原则（Interface Segregation Principle）：降低耦合度，接口单独设计，互相隔离
5. 迪米特法则，又称最少知道原则（Demeter Principle）：功能模块尽量独立
6. 合成复用原则（Composite Reuse Principle）：尽量使用聚合，组合，而不是继承

#### 工厂模式（2018-05-23）
[工厂模式](http://www.runoob.com/design-pattern/factory-pattern.html)这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。  
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  
优点：  
1. 一个调用者想创建一个对象，只要知道其名称就可以了。   
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。   
3. 屏蔽产品的具体实现，调用者只关心产品的接口。  
<br>
缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。  
缺点解决：可以通过反射机制，来解决每次增加一个产品时，都需要增加一个对象实现工厂的缺点（站在了巨人的肩膀上，学习了别人的代码！）

实现步骤：  
1. 创建接口Shape  
2. 创建实现接口的实体类Circle, Rectangle, Square  
3. 创建工厂类，生成基于给定信息的实体类的对象ShapeFactory  
4. 使用该工厂，通过传递类型信息来获取实体类的对象

#### 抽象工厂模式（2018-05-27）
[抽象工厂模式](http://www.runoob.com/design-pattern/abstract-factory-pattern.html)这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  
抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。  
意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。  
优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。  
缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。  
实现步骤：
1. 为形状创建一个接口Shape  
2. 创建实现形状接口的实体类Circle, Rectangle, Square  
3. 为颜色创建一个接口Color  
4. 创建实现颜色接口的实体类Red, Blue, Green  
5. 为 Color 和 Shape 对象创建抽象类来获取工厂AbstractFactory  
6. 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象ShapeFactory, ColorFactory  
7. 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂FactoryProcedure(工厂生成器)  
8. 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象  
9. 验证输出  
~~~
和工厂模式区别在于，除了定义工厂类之外还要需要创建一个超级工厂，即涵盖所有工厂类的抽象类AbstractFactory，通过工厂生成器来生成需要的工厂，然后通过工厂来创建实例
~~~  

#### 单例模式（2018-05-27）
[单例模式](http://www.runoob.com/design-pattern/singleton-pattern.html)是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  
注意：  
1. 单例类只能有一个实例  
2. 单例类必须自己创建自己的唯一实例  
3. 单例类必须给所有其他对象提供这一实例  
4. getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化  <br>
主要解决：一个全局使用的类频繁地创建与销毁  
优点： 
1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）  
2. 避免对资源的多重占用（比如写文件操作）  
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化  
使用场景：  
1. 要求生产唯一序列号  
2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来  
3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等  
实现步骤：  
1. 创建一个Singleton类SingleObject（SingleObject 类有它的私有构造函数和本身的一个静态实例）  
2. 从Singleton类获取唯一的对象  
3. 验证输出  
~~~
通过使被创建的类的构造方法为private，从而只能通过静态方法getInstance来返回私有的静态实例
~~~
单例模式6种实现方式  
1. 懒汉式，线程不安全  
2. 懒汉式，线程安全  
3. 饿汉式  
4. 双检锁/双重校验锁（DCL，即 double-checked locking）  
5. 登记式/静态内部类  
6. 枚举  <br>
经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

#### 代理模式（2018-05-27）
[代理模式](http://www.runoob.com/design-pattern/proxy-pattern.html)在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式<br>
主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。  
优点： 1、职责清晰。 2、高扩展性。 3、智能化。  
缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
实现步骤：  
1. 创建接口Image  
2. 创建实现接口的实体类RealImage, ProxyImage  
3. 当被请求时，使用ProxyImage来获取RealImage类的对象  